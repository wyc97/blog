---
title: 分布式锁
date: '2024-06-26T09:16:19.000Z'
excerpt: >-
  大体上有两种一种基于数据库做分布式锁，一种基于缓存 ### 1. 基于数据库分布式锁 思路就是使用排它锁 ![[Pasted image
  20240626173446.png]] 在查询语句后面加上 ...
tags:
  - Imported
category: Notes
---
大体上有两种一种基于数据库做分布式锁，一种基于缓存
### 1. 基于数据库分布式锁
思路就是使用排它锁
![[Pasted image 20240626173446.png]]
在查询语句后面加上 for update，数据库会在查询的过程中增加排它锁（需要注意的时数据库只有在通过索引检索的时候才会使用行级锁，否则使用表级锁）

**缺点**：即使我们这里使用了给 method_name 使用了索引，但实际上是否使用索引还需要根据执行计划来看，还有就是如果一个这个锁的占用时间很长的话，那么他会一直占着数据库的连接数。一旦类型的操作多了之后就会把数据库连接池撑爆。


### 2. 基于缓存的分布式锁
主要常见的是基于 redis 缓存实现的分布式锁

一个分布式锁有很多基本要求，一般来说有互斥性、可重入性、锁的性能等。
对于锁的互斥性，可以借助 setnx 来保证，因为这个操作本身就是原子性操作，并且结合 redis 的单线程就可以保证**锁的互斥性。**

因为 redis 本身就是基于内存的，所以**锁的性能**有保证。
1. 基于内存
2. 单线程（不需要进行线程和上下文切换）
3. 多路复用 I/O 模型：实现单个线程同时处理多个客户端连接
4. 高效的数据结构：redis 提供了多种的高效数据结构，如哈希表、有序集合、列表等，能够 O (1) 的时间复杂度内完成数据读写操作。

**什么是多路复用？**

Redis中的IO多路复用模式：

- (1)一个 socket 客户端与服务端连接时，会生成对应一个套接字描述符(套接字描述符是文件描述符的一种)，每一个 socket 网络连接其实都对应一个文件描述符。
- (2)多个客户端与服务端连接时，Redis 使用 **「I/O 多路复用程序」** 将客户端 socket 对应的 FD 注册到监听列表(一个队列)中。当客服端执行 read、write 等操作命令时，I/O 多路复用程序会将命令封装成一个事件，并绑定到对应的 FD 上。
- (3)**「文件事件处理器」**使用 I/O 多路复用模块同时监控多个文件描述符（fd）的读写情况，当 `accept`、`read`、`write` 和 `close` 文件事件产生时，文件事件处理器就会回调 FD 绑定的事件处理器进行处理相关命令操作。
- (4)整个文件事件处理器是在单线程上运行的，但是通过 I/O 多路复用模块的引入，实现了同时对多个 FD 读写的监控，当其中一个 client 端达到写或读的状态，文件事件处理器就马上执行，从而就不会出现 I/O 堵塞的问题，提高了网络通信的性能。
**Redis单线程？多线程？**

Redis 采⽤多个 IO 线程来处理⽹络请求，提⾼⽹络请求处理的并⾏度。Redis 多 IO 线程模型只⽤来处理处理网络数据的读写和协议解析，对于 Redis 的读写命令，依然是单线程处理。


至于**锁的可重入性**就是一个线程在没有锁释放的情况下可以重复获取同一个锁，通过 setnx 也可以实现。

加锁：
- 首先尝试获取锁，判断锁存不存在
- 如果不存在那么加上锁（唯一标识+计数器），
- 如果存在那么判断该锁和自己的唯一标识是否一样，不一样所获取失败，一样计数器+1。
解锁：
- 当线程需要释放锁的时候，计数器减 1
- 如果计数器等于 0 那么完全释放锁
- 如果计数器大于 0 那么该线程仍然持有该锁。

![[Pasted image 20240626222651.png]]
![[Pasted image 20240626222702.png]]

## 3. 锁和事务的粒度如何控制

分为两种情况：
1. 锁在事务之外
2. 锁在事务之内
对于第一种情况，会延长锁的时间，优点就是事务的时长不会收到锁的影响。
![[Pasted image 20240626225417.png]]
缺点就是锁的时间会拉长，跨越了整个事务。因为锁的时间更长了，那么整个系统的吞吐量也就会更低了。


对于第二种事务的粒度大于锁的粒度
![[Pasted image 20240626231724.png]]
这种方式的优点就是锁的时间短，并发性高一点。缺点就是在事务中间有可能会存在远程调用，拖长事务时间或者占用数据库连接数。

如何选择就看系统的需求，但一般来说先考虑加锁再加事务，虽然这样会导致锁的粒度变大，但是可有效避免数据库被占用等问题。

相比于数据库资源来说，使用 redis 资源成本更低。即使锁的时间变长影响也不是很大，毕竟我们加锁就是解决并发问题，悲观思想是可以接受的。这些长度其实可以忽略不计。
