---
title: Redis面试
date: '2024-08-05T04:44:43.000Z'
excerpt: >-
  ### Redis 集群模式  #### 1. 主从模式 #### 2. 哨兵模式 #### 3. Cluster 模式   ### Redis
  内存淘汰策略 1. noeviction：不会淘汰任何...
tags:
  - Imported
category: Notes
---
### Redis 集群模式

#### 1. 主从模式
#### 2. 哨兵模式
#### 3. Cluster 模式


### Redis 内存淘汰策略
1. noeviction：不会淘汰任何键值对，而是直接返回错误信息
2. allkeys-lru：从所有 key 中选择最近最少使用的那个 key 并删除
3. volatile-lru：从设置了过期时间的 key 中选择最近最少使用的那个 key 并删除。
4. allkeys-random：从所有的 key 中随机选择一个 key 并删除。
5. volatile-random：从设置了过期时间的 key 中随机选择 key 并删除。
6. volatile-ttl：从设置了过期时间的 key 中选择剩余时间最短的 key 并删除。
7. volatile-lfu：从设置了过期时间的 key 中选择访问频率最低的那个。
8. allkeys-lfu: 从所有的 key 中选择访问频率最低的那个。


**如何选择合适的淘汰策略：**

- **当 redis 作为缓存使用的时候，推荐使用 allkeys-lru 淘汰策略，默认情况下使用频率最低则后期命中的概率也低，所以将其淘汰。**
- **当 redis 作为半缓存半持久化使用时，可以使用 volatile-lru，但因为 redis 本身不建议保存持久化数据，所以只作为备选方案。**

### 如何处理 big key 问题
1. 有选择的删除 bigkey。
2. 设置合理的 ttl
3. 拆分：在代码中，将 big key 有意的拆分，比如根据日期或者用户。使用小键代替大键。或者可以使用 cluster 集群模式，将大 key 分散到不同的服务器上
4. 将这些大键存放单独的数据库中，从而实现对大键的部分迁移。

### Redis 实现延迟消息

主要就是通过 zset 这种数据结构来完成，拿订单举例：将订单的超时时间的时间戳（下单时间+超时时长）与订单号分别设置 score+member，这样 redis 会对 zset 按照 score 延时时间进行排序。然后在开启 redis 扫描任务，获取当前时间>score 的延时任务，扫描后取出订单号。
但是这种存在缺点，在高并发场景下，有可能多个消费者获取到同一个订单，就需要加分布式锁来解决，但这样就会降低吞吐量。


还有一种就是通过 Redission，Redission 中定义了分布式延迟队列 RDelayedQueue，一种基于 zset 结构实现的延迟队列，允许以指定的延迟时长将元素放到目标队列中。

