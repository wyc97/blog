---
title: redis
date: '2024-06-20T09:52:45.000Z'
excerpt: ' # Redis  ## 基础类型 - String - hash     - 散列类型，类似于map，可以存储结构化数据，比如对象（前提是这个对象没有嵌套其他对象）；提供字段和字段值的映射，字段值只...'
tags:
  - Imported
category: Notes
mindmap-plugin: basic
---

# Redis

## 基础类型
- String
- hash
    - 散列类型，类似于map，可以存储结构化数据，比如对象（前提是这个对象没有嵌套其他对象）；提供字段和字段值的映射，字段值只能存储字符串类型，实际场景中使用不多，一般对象类型都比较复杂嵌套了其他对象
- list（评论列表）
    - 有序可重复双向链表
        - l/rpush(往链表中插数据)；l/rpop(从链表推出数据)；lrang key start stop 查询指定开始和结束位置链表中的元素
- set（共同好友）
    - 无序不可重复的集合
        - 可以做一些交集(sinter)，并集(sunion)，差集（sdiff）操作
- zset（排行榜）
    - 有序不可重复集合，在set的基础上为每个集合中的元素关联一个分数zadd key score number
        - ziplist压缩表
            - 一个普通的双向链表，链表中每一项都占用独立的一块内存，各项之间用地址指针（或引用）连接起来。这种方式会带来大量的内存碎片，而且地址指针也会占用额外的内存。而ziplist却是将表中每一项存放在前后连续的地址空间内，一个ziplist整体占用一大块内存。为了节省内存 ziplist的每个元素所占的内存大小可以不同。
                - 有序集合保存的元素数量小于128个
                - 有序集合保存的所有元素的长度小于64字节
        - zskiplist跳表
            - 是一种有序的数据结构，它通过在每个节点中维护多个指向其它节点的指针，来达到快速访问的目的
- zset和list的区别
    - 列表是通过链表实现的，获取靠近两端的数据速度快，而有序集合是通过跳表来实现，即使读取中间元素也并不会很慢
    - 列表不能简单的改变元素的顺序，有序集合不同可以根据该表score的值来改变元素的顺序
    - 有序集合要比列表更耗内存

## 事务
- 和传统的数据库事务不太相同，redis只保证顺序执行事务中的命令，并保证全部执行，但是执行命令失败并不会发生回滚操作。并且事务中的命令可以部分成功。同样事务中的命令执行时原子性的（事务本身不是原子性的），不会别的事务干扰。redis事务开始后，会将后续的命令放入队列缓存中，直到执行exec命令后会按照顺序执行队列中的命令。
     redis事务没有隔离级别的概念
    - 命令性错误（类似于java的编译性错误）
        - 事务中的命令都不会执行成功
    - 语法错误
        - 事务中的正确的命令会执行成功，其他的执行失败
    - 乐观锁watch
        - 在监控某个键的过程中，如果该键在其他事务中被修改了，那么该事务接下来的命令均无效。
              一旦执行exec后 无论事务是否执行成功，watch状态都会被取消

## 持久化
-
    - RDB(默认)该方式是通过快照来完成的，满足一定条件之后，redis会将当前数据进行一次快照并持久化到硬盘中。
          过程：
          1.redis执行fork命令创建一个当前进程的副本（子进程）
          2.父进程继续接受并处理命令；子进程处理持久化操作将内存中的数据写入到硬盘的临时文件中。
          3.当子进程写入完成所有的数据后会用临时文件替换旧的rdb文件，至此一次快照操作完成。
-
    - AOF（默认不开启）该方式开启后，每执行一条会更改redis数据的命令后都会将该命令写入硬盘中的aof文件中（类似于日志记录）。
        - AOF文件重写（当AOF文件体积过大时，会自动进行文件重写操作）
            - rdb方式一样通过fork命令创建一个子进程并创建新的aof文件。
            - 子进程拥有主进程全部的数据副本，通过读取数据状态来分析得到一个能够回复当前数据状态的最小命令集合，将这集合写入到aof文件中。
            - 等到新的aof重写完成后，会发送一个消息给主进程，此时主进程会将aof重写缓存区中的命令集合全部写入新的aof文件中。
            - 对新的aof文件改名，并覆盖原来的aof文件
        - aof重写过程发生了异常关闭
            - 为现有的aof创建一个备份
            - 使用redis附带的redis-check-aof程序修复原来的aof文件 redis-check-aof --fix readonly.aof
            - 重启aof服务器，等待加载修复后的aof文件

## 消息模式
- 队列模式
    - 生产者生成消息放入队列中，消费者从队列中消费消息
        - 非阻塞式
            - lpush/lpop ;rpush/rpop
                - 当队列中没有数据的时候会一直返回nil
        - 阻塞式
            - blpop;brpop
                - 可以监听多个list在规定的时间内若list有数据就返回否则就返回null
- 发布订阅
    - 发布者对频道发布消息，订阅者可以订阅多个频道来接受消息。
        - publish channel message
        - subcribe channel[ch1 ...]
- https://www.cnblogs.com/qlqwjy/p/9763754.html

## 主从复制
- 作用
    - 读写分离
        - 主机执行写操作，从机执行读操作
    - 数据恢复
        - 持久化能够保证redis服务器异常关闭了也不会导致数据丢失，但当硬盘损坏了会导致数据丢失，针对可能发生的这一现象可通过主从复制机制来解决
- 原理
    - 全量同步
        - 发生在主从服务器第一次同步的过程中，首先从服务器会发送PSYNC请求同步数据
        - 主服务器接受到请求后会执行bgsave命令生成rdb文件并将这个文件发送给从服务器，在这一个过程中主服务器会执行并记录写命令到缓冲区中
        - 从服务器接受到rdb文件中会丢弃旧文件并载入新的文件（这一过程中是阻塞的）
        - 主服务器发送完rdb文件后会向从服务器发送缓冲区的写命令
        - 从服务器载入新的rdb文件并执行接收的命令
    - 增量同步
        - 主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令。
        - redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。
- 问题
    - 如果从服务器存储空间不够如何进行复制？
        - 无盘复制：
              子进程直接将RDB通过网络发送给从服务器，不使用磁盘作为中间存储。

## 哨兵机制
- 作用
    - 解决在主从复制架构中服务器出现故障的情况：
- 哨兵系统
    - 由一个或者多个哨兵实例组成，该哨兵系统下所有的哨兵节点都会监控任意多个主服务器以及该服务器下的从服务器
- 监控机制
    - 每个哨兵节点每10s会向主节点以及从节点发送info命令获取最新的服务器拓扑图，哨兵配置时只需要配置主节点的信息即可，通过向主节点发送info获取从节点的信息
    - 每个哨兵节点每隔2s会向redis数据节点的指定频道上发送该哨兵节点对于主节点的判断以及自己的信息，同时每个哨兵节点也会订阅该频道来了解其他哨兵节点的信息以及对于主节点的状态判断信息
    - 哨兵每隔1s会向主节点、从节点、其他哨兵节点发送一次ping敏玲做一次心跳检测，判断节点是否正常
- 节点状态
    - 主观下线
        - 哨兵节点每隔一秒会对实例（主节点、从节点、哨兵节点）进行心跳检测，如果实例回复的不是有效回复那么该哨兵节点认为实例主观下线
    - 客观下线
        - 当主观下线的节点是主节点时，此时该哨兵节点会发送请求给其他哨兵节点来获取哨兵节点对于主节点的判断，如果其他哨兵节点也认为该主节点主观下线，当主观下线的票数超过了选举数（quorum通过配置文件配置）那么就认为该主节点客观下线
            - sentinel monitor mymaster 127.0.0.1 6379 2
                  这最后的2表示的是quorum
- 哨兵选举
    - 如果主节点被判定为客观下线，那么就需要选举一个哨兵leader来进行接下来的故障转移操作
    - 1.每个在线的哨兵都可以成为leader，当哨兵1确认主节点客观下线时，会发送命令征求其他哨兵将自己设为leader
    - 2.其余哨兵接受命令后，同意或者拒绝哨兵1成为leader
    - 3.当哨兵1的同意票数大于num/2后吗，将成为leader
- 故障转移机制
    - 选择新的主节点
        - 1.过滤掉所有主观下线的从节点
        - 2.选择slave-priority最高的节点，没有就继续往下选择
        - 3.选择复制偏移量最大的节点，因为复制偏移量最大数据越完整
        - 4.选择run_id最小的节点（越小运行时间越长）
        - 复制偏移量
            - 主节点在处理完写命令后，会把命令的字节长度做累加记录，统计在 info replication 中的 master_repl_offset 指标中。
               从节点在接收到主节点发送的命令后，也会累加记录自身的偏移量，并且会每秒钟上报自身的复制偏移量给主节点。
               通过对比主从节点的复制偏移量，可以判断主从节点数据是否一致
    - 更新主从状态
        - 通过slaveof no one 命令让选出来的从节点成为主节点；并通过slaveof命令让其他节点成为从节点
        - 将已下线了主节点设置为新的主节点的从节点，当其恢复时，进行主从复制，变成从节点

## 缓存
- 缓存穿透
    - 大量请求同时访问缓存中不存在的key值，导致这些请求都会去访问数据库给服务器带来巨大压力
        - 增加校验比如用户校验、参数校验对于不合法的参数直接return
        - 对于查询结果为空的也缓存起来，可以将有效时间设置短一点，当有数据的时候更新缓存
        - 还可以通过布隆过滤器来过滤掉一些一定不会存在的数据直接return
            - 布隆过滤器其实就是一个一定容量的bit数组，将一些热点数据的key通过多个hash函数来计算hash值，通过hash值将数组对应下标的值设置为1。这样在查询的时候根据查询key的hash值来查看数组对应小标的值是否为1，如果不为1那么一定不存在，为1可能存在。
                  https://www.jianshu.com/p/2104d11ee0a2
- 缓存击穿
    - 大量请求集中访问同一热点数据，当这个数据失效时，这些请求就会击穿缓存访问到数据库。
        - 设置热点数据不过期
        - 加上互斥锁，保证同一个进程中针对同一个数据不会并发请求到 DB
```java
            String get(key){
                      String value=redis.get(key);
                      //缓存失效
                      if(value==null){
                      //只有key_mutex不存在才可以赋值，否则进不来
                          if(redis.setnx((key_mutex,1,3*60)==1){
                             //从数据库加载值
                             value=db.get(key);
                              //将值添加进redis并设置有效时间
                              redis.set(key,value,expire_secs);
                              //删除key_mutex(释放锁)
                              redis.del(key_mutex);
                          }else{
                              sleep(50);
                              get(key);
                          }
                      }else{
                          return value;
                  }
```
- 缓存雪崩
    - 大量的key在某一时间段内全部失效，造成该时间段内的并发请求全部访问到db。
        - 给key设置不同的有效时间，固定值+随机数
        - 加锁或者队列的方式保证缓存单线程写
        - 做双缓存，缓存A有有效时间，缓存B长期有效，查询的时候先查询缓存A，若有数据直接缓存，没有就查询缓存B直接返回，并且异步启动更新将AB缓存都更新
- 缓存更新一致性
    - 先更新数据库在更新缓存
        - 线程A更新数据库
        - 线程B更新数据库
        - 线程B更新缓存
        - 线程A更新缓存
        - 线程A先更新数据但是更新缓存的时候比线程B慢这样会导致脏数据
    - 先删除缓存在更新数据库
        - 线程A写数据，先删除缓存
        - 线程B读数据发现缓存中没有
        - 线程B从数据库中得到旧值
        - 线程B将旧值更新到缓存中
        - 线程A更新数据库
        - 如何解决上面的缓存不一致采用延迟双删策略
        - 缓存和数据库中的数据不一致，并且如果不给缓存设置有效时间那么缓存中的数据一直是不正确的
    - 先更新数据库在删除缓存
